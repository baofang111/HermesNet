# 消息协议设计 - 基本协议

> 消息协议是一种用于在计算机网络中不同系统或应用之间传递消息的规则和格式集合。它定义了消息的结构、格式、传输方式、编码方式，
> 以及如何处理消息的收发。这种协议确保了发送方和接收方能够理解彼此传递的数据，并能够正确地解码和响应

## 设计目标
IM 的核心场景是 A 客户端发送 __上行消息__ 到服务器，服务器发送 __下行消息__ 到 B 客户端


> 消息 可靠性 时序性 不重不漏



我们使用 传输层 使用 TCP 协议，安全层使用 TLS （ https） 协议，应用层选择 自研二进制协议 + 开源序列号协议

1、 TCP 协议保障了消息可靠的传送到网关服务上，相对于 UDP 来说，少处理了很多 bad case，因为 TCP 本身就是一个可靠性协议，
简化了开发成本，公司可以通过 业务层实现  __断线重连等弱网优化手段，来应对弱网环境 TCP 频繁断链的情况__

2、 TSL3.0 协议，优化了握手的速度提升了性能，同事可以较好的兼顾性能和安全性是一个高性价比的选择，但是如果在 gataway server 上实现
，由于 TSL 握手/加密 都是 CPU 密集型的操作，极端情况下会拉高 gateway server 的 CPU 使用率其造成性能抖动，为此我们选择在 L7 层负载均衡器上
实现 TLS 终止，使用 L7层负载均衡器会增加一跳的数据报的转发会造成性能损耗，不过可以使用 TLS 加速卡 （英特尔，QAT） 等硬件加速技术解决，
对于 IM 场景，如果仅仅考虑性能的话，可以在 L4 负载均衡器上实现 TLS 终止，减少对 L7 负载均衡器的依赖，因为 gateway server 本身也工作在 L7层当中

3、对于应用层一个简单灵活的二进制协议实现，可以分为固定消息头，变长消息头，消息体 三部分




# 消息协议涉及 - 可用性


* 消息及时： 服务端实时接收消息 并 实时在线发送
* 消息可达： 超时重试，ACK 确认
* 消息幂等： 分配 seqId, 服务端存储 seqId
* 消息有序:  sqpId 可比较，接受端能够按照发送端的顺序对消息进行排序

CID 使用趋势递增

CID 使用滑动窗口
    cid 严格递增的话，在弱网环境下，TCP 会经常连接 断链，会不断的重试，造成网络风暴，所以使用

长连接网关是一个有状态服务，使用 cid list 会造成内存浪费



### 上行消息 设计

### 消息转发

### 下行消息 设计

大体设计方案：

1、客户端 A 创建连接后，分配一个 clientId, 从 0 开始即可，发送一个消息时获得 clientId 并自增
2、启动一个消息计时器，等待 ACK 消息回复，或者超时后触发重传
3、基于 TCP 连接 将 msg1 发送给服务端
4、服务端请求 redis, 使用 sessionId 进行分片， incryBy 获得  seqId
5、异步写入 MQ ，保证消息的可靠存储
6、立即回复客户端 A ack 消息，高速客户端 B 的 ack 消息，或者超时后触发重传
7、启动一个下行消息定时器，等等客户端 B 的 ack 消息，或者超时后触发重传
8、客户端 A 收到 ack 消息后，取消定时器
9、服务端发起下行消息请求，将 msg1 发送给客户端 B 
10、客户端 B 根据当前 session 的 maxSqpID + 1 是否等于当前消息的 seqId 来觉得是否接受
11、客户端 B 回复服务端消息 已经确认 或者 拒绝
12、服务端根据 客户端 B 回复决定是进行消息补洞，还是关闭定时器





